'scopeName': 'source.as'
'fileTypes': [
  'as'
]
'name': 'Arrow'
'patterns': [
  # General (line) comment
  {
    'begin': '(^[ \\t]+)?(?=//)'
    'beginCaptures':
      '1':
        'name': 'punctuation.whitespace.comment.leading.arrow'
    'end': '(?!\\G)'
    'patterns': [
      {
        'begin': '//'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.arrow'
        'end': '\\n'
        'name': 'comment.line.arrow'
      }
    ]
  }

  # Shebang
  {
    'begin': '^(?=#\\!)'
    'beginCaptures':
      '1':
        'name': 'punctuation.whitespace.comment.leading.arrow'
    'end': '(?!\\G)'
    'patterns': [
      {
        'begin': '#\\!'
        'beginCaptures':
          '0':
            'name': 'punctuation.definition.comment.arrow'
        'end': '\\n'
        'name': 'comment.shebang.arrow'
      }
    ]
  }

  # Literal: Integer
  {
    'match': '\\b(?i:(0[xX_]\\h*))'
    'name': 'constant.numeric.integer.hexadecimal.arrow'
  }
  {
    'match': '\\b(?i:(0[oO][0-7_]+))'
    'name': 'constant.numeric.integer.octal.arrow'
  }
  {
    'match': '\\b(?i:(0[bB][01_]+))',
    'name': 'constant.numeric.integer.binary.arrow'
  }
  {
    'match': '\\b(?i:(\\d[0-9_]*\\.\\d[0-9_]*(e[\\-\\+]?\\d[0-9_]*)?))(?=[^a-zA-Z_])'
    'name': 'constant.numeric.float.arrow'
  }
  {
    'match': '\\b(?i:(\\d[0-9_]*e[\\-\\+]?\\d[0-9_]*))'
    'name': 'constant.numeric.float.arrow'
  }
  {
    'match': '\\b(?:(\\d[0-9_]*))'
    'name': 'constant.numeric.integer.arrow'
  }

  # Literal: Boolean
  {
    'match': '\\b(true|false)\\b'
    'name': 'constant.language.arrow'
  }

  # Operators
  {
    'match': '<\\=|>\\=|\\=\\=|<|>|\\!\\='
    'name': 'keyword.operator.comparison.arrow'
  }
  {
    'match': '\\+\\=|-\\=|\\*\\=|/\\=|%\\=|&\\=|\\|\\=|\\^\\='
    'name': 'keyword.operator.assignment.augmented.arrow'
  }
  {
    'match': '\\+|\\-|\\*|\\*\\*|/|%|&|\\||\\^|!'
    'name': 'keyword.operator.arithmetic.arrow'
  }
  {
    'match': '\\='
    'name': 'keyword.operator.assignment.arrow'
  }
  {
    'match': '\\:'
    'name': 'keyword.operator.annotate.arrow'
  }

  # Types: Storage
  {
    'match': '\\b(float(32|64)|(u)?int(8|16|32|64|128))\\b'
    'name': 'storage.type.arrow'
  }

  # Types: Basic
  {
    'match': '\\b(str|bool|char|byte|float|int)\\b'
    'name': 'support.type.arrow'
  }

  # String
  {
    'include': '#string_quoted_double'
  }

  # Built-in language constants
  {
    'captures':
      '1':
        'name': 'constant.language.arrow'
    'match': '\\b(None|_)\\b'
  }

  # Slot Declaration
  {
    'begin': '^\\s*(export)?\\s*(extern)?\\s*(let)\\s+'
    'beginCaptures':
      '1':
        'name': 'storage.modifier.slot.arrow'
      '2':
        'name': 'storage.modifier.slot.arrow'
      '3':
        'name': 'storage.modifier.slot.arrow'
    'end': '(\\:|\\=|\\;|\\n)'
    'endCaptures':
      '1':
        'name': 'keyword.operator.arrow'
    # 'name': 'meta.variable.arrow'
    'patterns': [
      {
        'include': '$base'
      }
      {
        'begin': '(?=[A-Za-z_][A-Za-z0-9_]*)'
        'contentName': 'variable.name.arrow'
        'end': '(?![A-Za-z0-9_])'
        'patterns': [
          {
            'include': '#entity_name'
          }
        ]
      }
    ]
  }

  # Storage Modifier
  {
    'match': '\\b(mutable|extern|export)\\b'
    'name': 'storage.modifier.arrow'
  }

  # Variable
  {
    'match': '\\b(let)\\b'
    'name': 'storage.modifier.slot.arrow'
  }

  # Function Declaration
  {
    'begin': '\\s*(def)\\s+(?=[A-Za-z_][A-Za-z0-9_]*\\s*\\()'
    'beginCaptures':
      '1':
        'name': 'storage.modifier.function.arrow'
      '2':
        'name': 'storage.modifier.function.arrow'
      '3':
        'name': 'storage.type.function.arrow'
    'end': '(\\))'
    'endCaptures':
      '1':
        'name': 'punctuation.definition.parameters.end.arrow'
    'name': 'meta.function.arrow'
    'patterns': [
      {
        'begin': '(?=[A-Za-z_][A-Za-z0-9_]*)'
        'contentName': 'entity.name.function.arrow'
        'end': '(?![A-Za-z0-9_])'
        'patterns': [
          {
            'include': '#entity_name'
          }
        ]
      },
      {
        'begin': '(\\()'
        'beginCaptures':
          '1':
            'name': 'punctuation.definition.parameters.begin.arrow'
        'contentName': 'meta.function.parameters.arrow'
        'end': '(?=\\))'
        'endCaptures':
          '1':
            'name': 'punctuation.definition.parameters.end.arrow'
        'patterns': [
          {
            'include': '$base'
          }
        ]
      }
    ]
  }

  # Structure
   {
    'begin': '^\\s*(struct)\\s+(?=[a-zA-Z_][a-zA-Z_0-9]*\\s*\\{)'
    'beginCaptures':
      '1':
        'name': 'storage.modifier.struct.arrow'
    # NOTE: This is `class` as autocomplete wants that
    'contentName': 'entity.name.type.class.arrow'
    'end': '\\s*(\\{)'
    'endCaptures':
      '1':
        'name': 'punctuation.section.struct.begin.arrow'
    'name': 'meta.struct.arrow'
    'patterns': [
      {
        'include': '#entity_name'
      }
    ]
  }

  # Keywords: Slot
  {
    'match': '\\b(let)\\b'
    'name': 'storage.modifier.slot.arrow'
  }

  # Keywords: Function
  {
    'match': '\\b(def)\\b'
    'name': 'storage.modifier.function.arrow'
  }

  # Keywords: Struct
  {
    'match': '\\b(struct)\\b'
    'name': 'storage.modifier.class.arrow'
  }

  # Keyword: Import
  {
    'captures':
      '1':
        'name': 'keyword.control.import.arrow'
      '2':
        'name': 'keyword.control.import.from.arrow'
    'match': '\\b(?:(import)|(from))\\b'
  }

  # Keyword: Conditional
  {
    'name': 'keyword.control.conditional.arrow'
    'match': '\\b(if|else|unless)\\b'
  }

  # Keyword: Loop
  {
    'name': 'keyword.control.repeat.arrow'
    'match': '\\b(for|while|until|loop)\\b'
  }

  # Keyword: Alter
  {
    'name': 'keyword.control.statement.arrow'
    'match': '\\b(break|continue|return)\\b'
  }

  # Keyword: Other
  {
    'captures':
      '1':
        'name': 'keyword.other.arrow'
    'match': '\\b(as)\\b'
  }
]

'repository':

  'escaped_char':
    'captures':
      '1':
        'name': 'constant.character.escape.hex.arrow'
      '2':
        'name': 'constant.character.escape.newline.arrow'
      '3':
        'name': 'constant.character.escape.backslash.arrow'
      '4':
        'name': 'constant.character.escape.double-quote.arrow'
      '5':
        'name': 'constant.character.escape.single-quote.arrow'
      '6':
        'name': 'constant.character.escape.bell.arrow'
      '7':
        'name': 'constant.character.escape.backspace.arrow'
      '8':
        'name': 'constant.character.escape.formfeed.arrow'
      '9':
        'name': 'constant.character.escape.linefeed.arrow'
      '10':
        'name': 'constant.character.escape.return.arrow'
      '11':
        'name': 'constant.character.escape.tab.arrow'
      '12':
        'name': 'constant.character.escape.vertical-tab.arrow'
    'match': '(\\\\x[0-9A-Fa-f]{2})|(\\\\\\n)|(\\\\\\\\)|(\\\\\\")|(\\\\\')|(\\\\a)|(\\\\b)|(\\\\f)|(\\\\n)|(\\\\r)|(\\\\t)|(\\\\v)'

  'string_quoted_double':
    'patterns': [
      {
        'begin': '(")'
        'beginCaptures':
          '1':
            'name': 'storage.type.string.arrow'
          '2':
            'name': 'punctuation.definition.string.begin.arrow'
        'end': '((?<=")(")|")|(\\n)'
        'endCaptures':
          '1':
            'name': 'punctuation.definition.string.end.arrow'
          '2':
            'name': 'meta.empty-string.double.arrow'
          '3':
            'name': 'invalid.illegal.unclosed-string.arrow'
        'name': 'string.quoted.double.single-line.arrow'
        'patterns': [
          {
            'include': '#escaped_char'
          }
        ]
      }
    ]

  'entity_name':
    'patterns': [
      {
        'include': '#illegal_names'
      }
      {
        'include': '#generic_name'
      }
    ]

  'generic_name':
    'match': '[A-Za-z_][A-Za-z0-9_]*'

  'illegal_names':
    'match': '\\b(and|as|break|class|continue|def|else|for|from|global|if|import|in|is|not|or|return|while|until|unless|loop|yield)\\b'
    'name': 'invalid.illegal.name.arrow'
